import{_ as T}from"./-Ugn9RHd.js";import{v as R,U as p,r as P,V as E,W as I,X as V,Y as N,z as O,A as M,Z as x,$ as B,a0 as H,e as _,a1 as U,d as z,a2 as $,c as W,u as j,j as q,a3 as S,k as A,L,E as K,o as F,n as X,p as Y,H as Z,g as G,i as J}from"./CbpaTVLF.js";import{u as Q}from"./Wb6dze4w.js";import{s as aa}from"./CXuwkuu6.js";import{s as D}from"./C04RlcEn.js";import"./B5RtmFoY.js";import"./DD4asW33.js";const ea=s=>s==="defer"||s===!1;function ta(...s){var u;const r=typeof s[s.length-1]=="string"?s.pop():void 0;typeof s[0]!="string"&&s.unshift(r);let[e,f,a={}]=s;if(typeof e!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof f!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=R(),y=f,g=()=>p.value,C=()=>t.isHydrating?t.payload.data[e]:t.static.data[e];a.server=a.server??!0,a.default=a.default??g,a.getCachedData=a.getCachedData??C,a.lazy=a.lazy??!1,a.immediate=a.immediate??!0,a.deep=a.deep??p.deep,a.dedupe=a.dedupe??"cancel";const h=a.getCachedData(e,t),w=h!=null;if(!t._asyncData[e]||!a.immediate){(u=t.payload._errors)[e]??(u[e]=p.errorValue);const o=a.deep?P:E;t._asyncData[e]={data:o(w?h:a.default()),pending:P(!w),error:I(t.payload._errors,e),status:P("idle"),_default:a.default}}const n={...t._asyncData[e]};delete n._default,n.refresh=n.execute=(o={})=>{if(t._asyncDataPromises[e]){if(ea(o.dedupe??a.dedupe))return t._asyncDataPromises[e];t._asyncDataPromises[e].cancelled=!0}if(o._initial||t.isHydrating&&o._initial!==!1){const d=o._initial?h:a.getCachedData(e,t);if(d!=null)return Promise.resolve(d)}n.pending.value=!0,n.status.value="pending";const m=new Promise((d,c)=>{try{d(y(t))}catch(b){c(b)}}).then(async d=>{if(m.cancelled)return t._asyncDataPromises[e];let c=d;a.transform&&(c=await a.transform(d)),a.pick&&(c=na(c,a.pick)),t.payload.data[e]=c,n.data.value=c,n.error.value=p.errorValue,n.status.value="success"}).catch(d=>{if(m.cancelled)return t._asyncDataPromises[e];n.error.value=H(d),n.data.value=_(a.default()),n.status.value="error"}).finally(()=>{m.cancelled||(n.pending.value=!1,delete t._asyncDataPromises[e])});return t._asyncDataPromises[e]=m,t._asyncDataPromises[e]},n.clear=()=>sa(t,e);const v=()=>n.refresh({_initial:!0}),i=a.server!==!1&&t.payload.serverRendered;{const o=V();if(o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const c=o._nuxtOnBeforeMountCbs;N(()=>{c.forEach(b=>{b()}),c.splice(0,c.length)}),O(()=>c.splice(0,c.length))}i&&t.isHydrating&&(n.error.value||h!=null)?(n.pending.value=!1,n.status.value=n.error.value?"error":"success"):o&&(t.payload.serverRendered&&t.isHydrating||a.lazy)&&a.immediate?o._nuxtOnBeforeMountCbs.push(v):a.immediate&&v();const m=x();if(a.watch){const c=M(a.watch,()=>n.refresh());m&&B(c)}const d=t.hook("app:data:refresh",async c=>{(!c||c.includes(e))&&await n.refresh()});m&&B(d)}const l=Promise.resolve(t._asyncDataPromises[e]).then(()=>n);return Object.assign(l,n),l}function sa(s,r){r in s.payload.data&&(s.payload.data[r]=void 0),r in s.payload._errors&&(s.payload._errors[r]=p.errorValue),s._asyncData[r]&&(s._asyncData[r].data.value=void 0,s._asyncData[r].error.value=p.errorValue,s._asyncData[r].pending.value=!1,s._asyncData[r].status.value="idle"),r in s._asyncDataPromises&&(s._asyncDataPromises[r]&&(s._asyncDataPromises[r].cancelled=!0),s._asyncDataPromises[r]=void 0)}function na(s,r){const e={};for(const f of r)e[f]=s[f];return e}function ra(s){return U(()=>{var e;const r=(e=V())==null?void 0:e.appContext.app.$nuxt;return r?r.runWithContext(s):s()})}const ia={class:"hand-statistic-widget"},k=3e4,ya=z({__name:"widget",async setup(s){let r,e;$(i=>({"15c94d42":_(C)}));const f=j(),a=q({tanks:[],accountId:S.toNumber(f.query.accountId)??0,metricsOpacity:S.toNumber(f.query.opacity)??1,metricsWidth:S.toNumber(f.query.width)??0,hasAnimateStartClass:!1}),{$formatter:t}=R(),y=P([{key:"battles",label:t.stat.accountProp("battles"),value:0},{key:"winRate",label:t.stat.accountProp("winRate"),value:0},{key:"damagePerBattle",label:t.stat.accountProp("damagePerBattle"),value:0}]),g=Q(),C=W(()=>k+"ms");[r,e]=ra(async()=>ta("get-tanks-vehicles",async()=>await g.getTanksVehicles().then(()=>!0))),await r,e();function h(){var l;let i={};a.tanks.forEach(u=>{i=D.sum(i,u.stat)}),(l=y.value)==null||l.forEach(u=>{u.key==="winRate"?u.value=D.winRate(i):u.key==="damagePerBattle"?u.value=D.damagePerBattle(i):u.value=i.battles??0})}function w(i){return{...i,battles:(i.losses||0)+(i.wins||0),winRate:D.winRate(i),damagePerBattle:D.damagePerBattle(i)}}function n(i){const l={...i.tank,stat:i.stat};return l.stat=w(l.stat),l.lastUpdateTime=i.lastUpdateTime,l}async function v(){a.hasAnimateStartClass=!1;const{data:i}=await K.handStat.tanks.get(a.accountId);a.tanks=[],i.raw.forEach(l=>{var o;const u=(o=g.vehicles)==null?void 0:o[l.tankId];u&&a.tanks.push(n({tank:u,stat:l.stat,lastUpdateTime:l.lastBattleTime}))}),h(),a.hasAnimateStartClass=!0}return A(async()=>{if(!a.accountId)return L().add({type:"warning",message:"ID пользователя не определён"});await v(),aa(v,k)}),(i,l)=>{const u=T;return F(),X("div",ia,[Y("div",{class:Z(["hand-statistic-widget__line",[_(a).hasAnimateStartClass?"hand-statistic-widget__line--animate":""]])},null,2),G(u,{modelValue:_(y),"onUpdate:modelValue":l[0]||(l[0]=o=>J(y)?y.value=o:null),opacity:_(a).metricsOpacity,width:_(a).metricsWidth},null,8,["modelValue","opacity","width"])])}}});export{ya as default};
